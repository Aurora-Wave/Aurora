

class EMSComment:
    """
    Represents a physiological comment (annotation) in a recording.
    Comments are global to the entire file and synchronized across all channels.
    Includes timing, raw text, and metadata to assist with navigation, editing, and labeling.
    """

    def __init__(self, text, time_sec, comment_id, user_defined=False, label=None):
        self.text = text                    # Comment text
        self.time = time_sec                # Absolute time in seconds (universal)
        self.comment_id = comment_id        # Unique ID (local to file)
        self.user_defined = user_defined    # Whether this comment was added manually by the user
        self.label = label or text          # Display label, defaults to text if not provided

    def to_dict(self):
        """
        Return the comment as a dictionary, useful for table display or export.
        """
        return {
            "id": self.comment_id,
            "text": self.text,
            "time_sec": self.time,
            "user_defined": self.user_defined
        }

    def update(self, text=None, time=None, label=None):
        """
        Update comment text, time (e.g. after user correction).
        """
        if text is not None:
            self.text = text
        if time is not None:
            self.time = time
        if label is not None:
            self.label = label

    def __repr__(self):
        tag = "(user)" if self.user_defined else ""
        return f"EMSComment(id={self.comment_id}, time={self.time:.2f}s, label='{self.label}' {tag}, text='{self.text}')"


from PySide6.QtCore import QObject, Signal
from typing import Optional


class CommentManager(QObject):
    """
    Event-driven comment manager for business logic and validation.
    
    Architecture:
    - Validates comment operations and emits events
    - No direct data manipulation - delegates to DataManager
    - Pure business logic layer without state management
    """
    
    # Event-driven signals - CommentManager requests, DataManager handles
    comment_create_requested = Signal(str, dict)  # (file_path, comment_data)
    comment_update_requested = Signal(str, str, dict)  # (file_path, comment_id, update_data)
    comment_delete_requested = Signal(str, str)  # (file_path, comment_id)
    
    def __init__(self):
        super().__init__()
        from aurora.core import get_user_logger
        self.logger = get_user_logger("CommentManager")
        # Note: Comment IDs now generated dynamically by DataManager based on max existing ID
    
    def request_add_comment(self, file_path: str, text: str, time_sec: float, label: str = None):
        """Request comment creation through event system"""
        # Validate input
        if not text.strip():
            raise ValueError("Comment text cannot be empty")
        if time_sec < 0:
            raise ValueError("Time cannot be negative")
            
        # Create comment data - ID will be generated by DataManager
        comment_data = {
            'text': text.strip(),
            'time_sec': time_sec,
            'label': label.strip() if label else None,
            'user_defined': True
            # Note: 'comment_id' will be added by DataManager using get_next_comment_id()
        }
        
        # Emit event
        self.comment_create_requested.emit(file_path, comment_data)
        self.logger.debug(f"Comment creation requested at {time_sec:.2f}s for {file_path}")
        
    def request_update_comment(self, file_path: str, comment_id: str, **updates):
        """Request comment update through event system"""
        # Validate updates
        if 'text' in updates and not updates['text'].strip():
            raise ValueError("Comment text cannot be empty")
        if 'time_sec' in updates and updates['time_sec'] < 0:
            raise ValueError("Time cannot be negative")
            
        # Emit event
        self.comment_update_requested.emit(file_path, comment_id, updates)
        self.logger.debug(f"Comment update requested for {comment_id} in {file_path}")
        
    def request_delete_comment(self, file_path: str, comment_id):
        """Request comment deletion through event system"""
        # Convert to string for consistent handling
        comment_id_str = str(comment_id)
        self.logger.debug(f"About to emit signal - file_path: '{file_path}', comment_id: '{comment_id_str}' (type: {type(comment_id_str)})")
        self.comment_delete_requested.emit(file_path, comment_id_str)
        self.logger.debug(f"Signal emitted successfully for comment deletion: {comment_id_str} in {file_path}")
    

# Global instance
_comment_manager_instance = None

def get_comment_manager() -> CommentManager:
    """Get the global CommentManager instance."""
    global _comment_manager_instance
    if _comment_manager_instance is None:
        _comment_manager_instance = CommentManager()
    return _comment_manager_instance